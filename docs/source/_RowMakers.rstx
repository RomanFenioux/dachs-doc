RowMakers
=========
*TAItoTT(tai)*
  returns TDT for a (datetime.datetime) TAI.
  

*TTtoTAI(tdt)*
  returns TAI for a (datetime.datetime) TDT.
  

*bYearToDateTime(bYear)*
  returns a datetime.datetime instance for a fractional Besselian year.
  
  This uses the formula given by Lieske, J.H., A&A 73, 282 (1979).
  

*computeMean(val1, val2)*
  returns the mean value between two values.
  
  Beware: Integer division done here for the benefit of datetime calculations.
  
  >>> computeMean(1.,3)
  2.0
  >>> computeMean(datetime.datetime(2000, 10, 13), 
  ...   datetime.datetime(2000, 10, 12))
  datetime.datetime(2000, 10, 12, 12, 0)
  

*dateTimeToJYear(dt)*
  returns a fractional (julian) year for a datetime.datetime instance.
  

*dateTimeToJdn(dt)*
  returns a julian day number (including fractionals) from a datetime
  instance.
  

*dateTimeToMJD(dt)*
  returns a modified julian date for a datetime instance.
  

*dmsToDeg(dmsAngle, sepChar=None)*
  returns the degree minutes seconds-specified dmsAngle as a 
  float in degrees.
  
  >>> "%3.8f"%dmsToDeg("45 30.6")
  '45.51000000'
  >>> "%3.8f"%dmsToDeg("45:30.6", ":")
  '45.51000000'
  >>> "%3.8f"%dmsToDeg("-45 30 7.6")
  '-45.50211111'
  >>> dmsToDeg("junk")
  Traceback (most recent call last):
  ValueError: Invalid dms value with sepChar None: 'junk'
  

*genLimitKeys(inputKey)*
  yields _MAX and _MIN inputKeys from a single input key.
  
  This also tries to sensibly fix descriptions and ucds.
  This is mainly for datalink metaMakers; condDescs may use a 
  similar thing, but that's not exposed to RDs.
  

*getAccrefFromStandardPubDID(pubdid, authBase=u'ivo://x-unregistred/~?')*
  returns an accref from a standard DaCHS PubDID.
  
  This is basically the inverse of getStandardPubDID.  It will raise
  ValueErrors if pubdid doesn't start with ivo://<authority>/~?.
  
  The function does not check if the remaining characters are a valid
  accref, much less whether it can be resolved.
  

*getFileStem(fPath)*
  returns the file stem of a file path.
  
  The base name is what remains if you take the base name and split off
  extensions.  The extension here starts with the last dot in the file name,
  except up to one of some common compression extensions (.gz, .xz, .bz2, 
  .Z, .z) is stripped off the end if present before determining the extension.
  
  >>> getFileStem("/foo/bar/baz.x.y")
  'baz.x'
  >>> getFileStem("/foo/bar/baz.x.gz")
  'baz'
  >>> getFileStem("/foo/bar/baz")
  'baz'
  

*getFlatName(accref)*
  returns a unix-compatible file name for an access reference.
  
  The file name will not contain terrible characters, let alone
  slashes.  This is used to, e.g., keep all previews in one directory.
  

*getHTTPPar(inputData, parser, single=False, forceUnique=False)*
  returns a parsed value from inputData.
  
  inputData may be
  
  * None -- the function will return None
  * an empty list -- the function will return None
  * a value other than a list -- as if it were a list of length 1
  * a list -- the function will return a list of parsed items
  
  This is of conveniently and robustly pulling out data from stuff coming
  out of inputKeys without multiplicity.
  
  If you pass single=True, you'll get exactly one value (or None).  The
  value will be the first one from a sequence.
  
  If you pass forceUnique=True, a ValueError will be raised if
  inputData is longer than one.
  

*getInputsRelativePath(absPath, liberalChars=True)*
  returns absath relative to the DaCHS inputsDir.
  
  If absPath is not below inputsDir, a ValueError results.  On liberalChars,
  see getRelativePath.
  
  In rowmakers and rowfilters, you'll usually use the macro
  \inputRelativePath that inserts the appropriate code.
  

*getQueryMeta()*
  returns a query meta object from somewhere up the stack.
  
  This is for row makers running within a service.  This can be used
  to, e.g., enforce match limits by writing getQueryMeta()["dbLimit"].
  

*getStandardPubDID(path)*
  returns the standard DaCHS PubDID for path.
  
  The publisher dataset identifier (PubDID) is important in protocols like
  SSAP and obscore.  If you use this function, the PubDID will be your
  authority, the path compontent ~, and the inputs-relative path of 
  the input file as the parameter.
  
  path can be relative, in which case it is interpreted relative to
  the DaCHS inputsDir.
  
  You *can* define your PubDIDs in a different way, but you'd then need
  to provide a custom descriptorGenerator to datalink services (and
  might need other tricks).  If your data comes from plain files, use 
  this function.
  
  In a rowmaker, you'll usually use the \standardPubDID macro.
  

*hmsToDeg(hms, sepChar=None)*
  returns the time angle (h m s.decimals) as a float in degrees.
  
  >>> "%3.8f"%hmsToDeg("22 23 23.3")
  '335.84708333'
  >>> "%3.8f"%hmsToDeg("22:23:23.3", ":")
  '335.84708333'
  >>> "%3.8f"%hmsToDeg("222323.3", "")
  '335.84708333'
  >>> hmsToDeg("junk")
  Traceback (most recent call last):
  ValueError: Invalid time with sepChar None: 'junk'
  

*iterSimpleText(f)*
  iterates over physLineNumber, line in f with some usual 
  conventions for simple data files.
  
  You should use this function to read from simple configuration and/or
  table files that don't warrant a full-blown grammar/rowmaker combo.
  The intended use is somewhat like this::
  
    with open(rd.getAbsPath("res/mymeta")) as f:
      for lineNumber, content in iterSimpleText(f):
        try:
          ...
        except Exception, exc:
          sys.stderr.write("Bad input line %s: %s"%(lineNumber, exc))
  
  The grammar rules are, specifically:
  
  * leading and trailing whitespace is stripped
  * empty lines are ignored
  * lines beginning with a hash are ignored
  * lines ending with a backslash are joined with the following line;
    to have intervening whitespace, have a blank in front of the backslash.
  

*jdnToDateTime(jd)*
  returns a datetime.datetime instance for a julian day number.
  

*killBlanks(literal)*
  returns the string literal with all blanks removed.
  
  This is useful when numbers are formatted with blanks thrown in.
  
  Nones are passed through.
  

*lastSourceElements(path, numElements)*
  returns a path made up from the last numElements items in path.
  

*makeAbsoluteURL(path)*
  returns a fully qualified URL for a rooted local part.
  

*makeProductLink(key, withHost=True)*
  returns the URL at which a product can be retrieved.
  
  key can be an accref string or an RAccref
  

*makeSitePath(path)*
  returns a rooted local part for a server-internal URL.
  
  uri itself needs to be server-absolute; a leading slash is recommended
  for clarity but not mandatory.
  

*makeTimestamp(date, time)*
  makes a datetime instance from a date and a time.
  

*mjdToDateTime(mjd)*
  returns a datetime.datetime instance for a modified julian day number.
  
  Beware: This loses a couple of significant digits due to transformation
  to jd.
  

*parseAngle(literal, format, sepChar=None)*
  converts the various forms angles might be encountered to degrees.
  
  format is one of hms, dms, fracHour.  For sexagesimal/time angles, 
  you can pass a sepChar (default: split at blanks) that lets you
  specify what separates hours/degrees, minutes, and seconds.
  
  >>> str(parseAngle("23 59 59.95", "hms"))
  '359.999791667'
  >>> "%10.5f"%parseAngle("-20:31:05.12", "dms", sepChar=":")
  ' -20.51809'
  >>> "%010.6f"%parseAngle("21.0209556", "fracHour")
  '315.314334'
  

*parseBooleanLiteral(literal)*
  returns a python boolean from some string.
  
  Boolean literals are strings like True, false, on, Off, yes, No in
  some capitalization.
  

*parseDate(literal, format='%Y-%m-%d')*
  returns a datetime.date object of literal parsed according to the
  strptime-similar format.
  
  The function understands the special dateFormat !!julianEp 
  (stuff like 1980.89).
  

*parseFloat(literal)*
  returns a float from a literal, or None if literal is None or an empty
  string.
  
  Temporarily, this includes a hack to work around a bug in psycopg2.
  
  >>> parseFloat("   5e9 ")
  5000000000.0
  >>> parseFloat(None)
  >>> parseFloat("  ")
  >>> parseFloat("wobbadobba")
  Traceback (most recent call last):
  ValueError: could not convert string to float: wobbadobba
  

*parseISODT(literal)*
  returns a datetime object for a ISO time literal.
  
  There's no real timezone support yet, but we accept and ignore various
  ways of specifying UTC.
  
  >>> parseISODT("1998-12-14")
  datetime.datetime(1998, 12, 14, 0, 0)
  >>> parseISODT("1998-12-14T13:30:12")
  datetime.datetime(1998, 12, 14, 13, 30, 12)
  >>> parseISODT("1998-12-14T13:30:12Z")
  datetime.datetime(1998, 12, 14, 13, 30, 12)
  >>> parseISODT("1998-12-14T13:30:12.224Z")
  datetime.datetime(1998, 12, 14, 13, 30, 12, 224000)
  >>> parseISODT("19981214T133012Z")
  datetime.datetime(1998, 12, 14, 13, 30, 12)
  >>> parseISODT("19981214T133012+00:00")
  datetime.datetime(1998, 12, 14, 13, 30, 12)
  >>> parseISODT("junk")
  Traceback (most recent call last):
  ValueError: Bad ISO datetime literal: junk
  

*parseInt(literal)*
  returns an int from a literal, or None if literal is None or an empty
  string.
  
  >>> parseInt("32")
  32
  >>> parseInt("")
  >>> parseInt(None)
  

*parseTime(literal, format='%H:%M:%S')*
  returns a datetime.timedelta object for literal parsed according
  to format.
  
  For format, you can the magic values !!secondsSinceMidnight,
  !!decimalHours or a strptime-like spec using the H, M, and S codes.
  
  >>> parseTime("89930", "!!secondsSinceMidnight")
  datetime.timedelta(1, 3530)
  >>> parseTime("23.4", "!!decimalHours")
  datetime.timedelta(0, 84240)
  >>> parseTime("3.4:5", "%H.%M:%S")
  datetime.timedelta(0, 11045)
  >>> parseTime("20:04", "%H:%M")
  datetime.timedelta(0, 72240)
  

*parseTimestamp(literal, format='%Y-%m-%dT%H:%M:%S')*
  returns a datetime.datetime object of literal parsed according to the
  strptime-similar format.
  
  A ValueError is raised if literal doesn't match format (actually,
  a parse with essentially DALI-standard ISO representation is always tried)
  

*parseWithNull(literal, baseParser, nullLiteral=<Undefined>, default=None, checker=None)*
  returns default if literal is nullLiteral, else baseParser(literal).
  
  If checker is non-None, it must be a callable returning True if its
  argument is a null value.
  

*quoteProductKey(key)*
  returns key as getproduct URL-part.
  
  if key is a string, it is quoted as a naked accref so it's usable
  as the path part of an URL.  If it's an RAccref, it is just stringified.
  The result is something that can be used after getproduct in URLs
  in any case.
  

*requireValue(val, fieldName)*
  returns val unless it is None, in which case a ValidationError
  for fieldName will be raised.
  

*scale(val, factor, offset=0)*
  returns val*factor+offset if val is not None, None otherwise.
  
  This is when you want to manipulate a numeric value that may be NULL.
  It is a somewhat safer alternative to using nullExcs with scaled values.
  

*toMJD(literal)*
  returns a modified julian date made from some datetime representation.
  
  Valid representations include:
  
  * MJD (a float smaller than 1e6)
  * JD (a float larger than 1e6)
  * datetime.datetime instances
  * ISO time strings.
  
